var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = RedBlackGraph","category":"page"},{"location":"#RedBlackGraph.jl","page":"Home","title":"RedBlackGraph.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RedBlackGraph. RedBlackGraphs are DAGs of interleaved Binary Trees.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When representing binary relationships, such as familial relationships, a number of approaches may be utilized including: ad-hoc, general graphs, specialized tables or charts. As I've explored different representations, a specialized mathematical representation has emerged. This mathematical representation is useful as the underpinnings of dynamic graph algorithms for use cases that include graph analysis, relationship calculation, loop detection, loop prevention, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying mathematical model is a directed, acyclic graph of multiple, interleaved binary trees, designated as a RedBlackGraph. The name, RedBlackGraph, derives from superficial similarity to Red Black Trees. Red Black Trees are binary trees such that each node has an extra, color bit (red or black). This color bit is used to balance the tree as modifications are made. In a RedBlackGraph each vertex also has an extra, color bit, rather than utilizing the color bit for balancing, the color bit is used to constrain edges between vertices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"I will provide a formal definition of a RedBlackGraph, as well as explore a number of interesting emergent properties. I will also examine several applications of RedBlackGraphs to illustrate the utility of using this mathematical model for familial relationships.","category":"page"},{"location":"#Formal-Definition","page":"Home","title":"Formal Definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A RedBlackGraph is a network, mathscrN, consisting of a directed graph, G = (VE), and a relationship function, r(mathbfumathbfv)rightarrow mathbbA. Where:","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbbA, Avus numbers, are: mathbbN cup 0 colorred1 textwhere begincases colorred1 lt 1  colorred1 text is even  textotherwise colorred1 text behaves as 1 endcases\nAny given vertex must have a color, either red or black\nAny given vertex can have at most one outbound edge to a vertex of a given color\nEvery vertex has an edge to itself where: r(mathbfvmathbfv)rightarrow begincases colorred1  textif mathbfv text is a red vertex 1  textif mathbfvtext is a black vertex endcases\nIf there is no path in G from mathbfu to mathbfv, r(mathbfumathbfv)rightarrow 0\nFor all other mathbfu, mathbfv not covered by constraints 4 and 5, r(mathbfumathbfv)rightarrow x, were x is generated by walking the shortest path (assume uniform edge weights) from mathbfu to mathbfv as follows:\nx leftarrow 1\nwalk the edge along the shortest path and update x as follows: x leftarrow begincases x ll 0  textif resultant vertex is red  x ll 1  textif resultant vertex is black endcases (ll is bitwise shift left)\nrepeat step two until mathbfv is reached","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Note: a new class of numbers are defined, Avus numbers, as above. Avus, in Latin, refers to ancestors. As this number system is derived from working on representing ancestry, the name seems appropriate.)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The relationships resulting from sexual reproduction can be modeled by a RedBlackGraph, arbitrarily assigning vertices that are male as Red and vertices that are female as Black with direction of edges being from the offspring to the parent.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: simple-graph)","category":"page"},{"location":"#Observation","page":"Home","title":"Observation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a given vertex in a RedBlackGraph there are two distinct sub-graphs or \"views\" or perspectives, for a given vertex: Descendancy and Ancestry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Descendancy is the sub-graph for a given vertex that consists of all vertices and edges that can follow a graph traversal and arrive at the given node.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: simple-graph-descendancy)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ancestry is the sub-graph for a given vertex that consists of all the vertices and edges reachable by following out-bound edges. This sub-graph is a well-formed binary tree.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: simple-graph-ancestry)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Ancestry sub-graph from a given mathbfu is a well-formed binary tree. r(mathbfumathbfv) is defined as to number the nodes of the tree as they are encountered in a breadth first search. A concrete example of r(mathbfumathbfv) is observed in a pedigree chart (common in family history research). See fig. Pedigree Chart.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: pedigree)","category":"page"},{"location":"#RedBlackGraph-Adjacency-Matrices-and-Avus-Arithmetic","page":"Home","title":"RedBlackGraph Adjacency Matrices and Avus Arithmetic","text":"","category":"section"},{"location":"#Adjacency-Matrix","page":"Home","title":"Adjacency Matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An adjacency matrix is a square matrix used to represent a graph. The elements of the matrix are 1 (or edge weight) if there is an edge between the vertices represented by the column index and the row index. Slightly more formally, for G with a vertex set V, the adjacency matrix is a square V x V matrix, A such that A_ij is 1 if there exists an edge from mathbfi to mathbfj and 0 otherwise.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given the above example graph and choosing indices for the vertices as follows: 0 - Female Offspring, 1 - Male Offspring, 2 - Male Progenitor, 3 - Female Progenitor, the graph would be represented by the following adjacency matrix.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A = beginbmatrix 0  0  1  1  0  0  1  1  0  0  0  0  0  0  0  0  endbmatrix","category":"page"},{"location":"#RedBlackGraph-Adjacency-Matrix","page":"Home","title":"RedBlackGraph Adjacency Matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let's define the adjacency matrix for a RedBlackGraph only slightly differently. R_ij=r(mathbfi mathbfj) if there is a relationship from mathbfi to mathbfj and 0 otherwise. The following is the RedBlackGraph adjacency matrix for the above example graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"R = beginbmatrix 1  0  2  3  0  colorred1  2  3  0  0  colorred1  0  0  0  0  1 \nendbmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"Observe the following properties:","category":"page"},{"location":"","page":"Home","title":"Home","text":"trace(R) = V_black - V_red","category":"page"},{"location":"","page":"Home","title":"Home","text":"V = V_black + V_red","category":"page"},{"location":"","page":"Home","title":"Home","text":"V_black = fracV + trace(R)2","category":"page"},{"location":"","page":"Home","title":"Home","text":"V_red = fracV - trace(R)2","category":"page"},{"location":"#Transitive-Closure","page":"Home","title":"Transitive Closure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Computing the transitive closure of an adjacency matrix, A, results in the reachability a matrix, A^+, that shows all vertices that are reachable from any given vertex. If A_ij == 1 there is a path from mathbfv_i to mathbfv_j.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The transitive closure of a RedBlackGraph adjacency matrix, R, is defined to be the relationship matrix, R^+. In addition to reachability, R^+ is defined in such that if R^+_ij == mathbfn and mathbfn is non-zero, then from mathbfn we can derive both the path length and the explicit traversal path from mathbfi to mathbfj.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As an example consider the following graph, where each node has been labeled with a vertex index:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: simple-graph-transitive-closure)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By inspection:","category":"page"},{"location":"","page":"Home","title":"Home","text":"R = beginbmatrix colorred1  2  3  0  0  0  colorred1  0  2  0  0  0  1  0  0  0  0  0\n colorred1  0  2  0  0  0  1  endbmatrixtext and R^+ = beginbmatrix colorred1  2  3  4 \n0  0  colorred1  0  2  0  0  0  1  0  0  0  0  0  colorred1  0  2  4  5  8  1 \nendbmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"Before examining how to generate R^+ from R, consider the following observations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r(mathbfumathbfv) is even when mathbfv is red and odd when black. (By convention colorred1 is considered even.)\nThe path length is inherent in r(mathbfumathbfv), and is trivially derived by taking the integral portion of log_2(r(mathbfumathbfv)).\nThe traversal path is also inherent in r(mathbfumathbfv) and can be derived by reversing r's definition and successively right shifting out bits (of a base_2 integer representation) and using that bit to \"walk\" the traversal edge to a red vertex or black vertex.\nThe diameter of R^+ is given by log_2(max(r(mathbfumathbfv))).","category":"page"},{"location":"#Avus-Arithmetic","page":"Home","title":"Avus Arithmetic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As constructing R^+ by inspection is cumbersome for non-trivial cases, let's explore a method to algorithmically derive R^+ from R.","category":"page"},{"location":"#Transitive-Relationship-Function-or-Avus-Product","page":"Home","title":"Transitive Relationship Function or Avus Product","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first step requires defining a transitive relationship function. To illustrate, consider 3 vertices: mathbfu , mathbfv and mathbfw. Further, assume that there is a path from mathbfu to mathbfv and from mathbfv to mathbfw. I'll define the function, f(r(mathbfumathbfv)r(mathbfvmathbfw))rightarrow r(mathbfumathbfw), as the avus product, e.g. r(mathbfumathbfw)=r(mathbfumathbfv) * r(mathbfvmathbfw).","category":"page"},{"location":"","page":"Home","title":"Home","text":"If r(mathbfumathbfv)=4 (mathbfv is mathbfu's paternal grandfather) and r(mathbfvmathbfw)=7 (mathbfw is mathbfv's maternal grandmother). Using either the definition of r or transcribing mathbfv's pedigree into the proper place in mathbfu's pedigree chart we see that r(mathbfumathbfw)=19, or 19 = 4 * 7. To further explore this, consider the following (r(mathbfxmathbfy) represented in base-2 for illustrative purposes):","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathbfv's relationship to mathbfu mathbfw's relationship to mathbfv r(mathbfumathbfv) r(mathbfvmathbfw) r(mathbfumathbfw)\nfather father 10 10 100\nfather mother 10 11 101\nmother father 11 10 110\nmother mother 11 11 111\nfather paternal grandfather 10 100 1000\nmaternal grandmother paternal grandfather 111 100 11100","category":"page"},{"location":"","page":"Home","title":"Home","text":"To complete the definition of the Avus Product, the following conventions are imposed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"colorred1 = colorred1 * 1\ncolorred1 = 1 * colorred1\nFor all other cases, colorred1 is treated as 1","category":"page"},{"location":"#Avus-Sum","page":"Home","title":"Avus Sum","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It is natural to pair multiplication with addition for linear algebra operations (matrix multiplication, matrix distance product, etc.) a min-Avus product pairing conforms to the definition of RedBlackGraphs with a slight modification required for implementation in a typical RAM computer, namely colorred1=2^mathbfw-1, where mathbfw is the word size of the numeric type. Aside from colorred1, the range of r(mathbfumathbfv) is mathbbN. It is therefore, natural to utilize unsigned numeric types to represent Avus numbers. Additionally, assume the convention min(0)=infty. The min function needs to be aware of both these conventions. These conventions define Avus sum, e.g. colorred1 = colorred1 + 5 and 2 = 37 + 2 and 3 = 0 + 3.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To complete the definition of the Avus Sum, the following conventions are imposed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"colorred1 = colorred1 + 1\ncolorred1 = 1 + colorred1\nFor all other cases, colorred1 is treated as 1","category":"page"},{"location":"#Transitive-Closure-for-RedBlackGraph-Adjacency-Matrix","page":"Home","title":"Transitive Closure for RedBlackGraph Adjacency Matrix","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transitive closure of an adjacency matrix can be computed a number of ways, a simple approach is the  Floyd-Warshall Algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Summarized, this algorithm is a tripple loop across the matrix indices continuously updating the current transitive  relationship, A^+_ij, if there is a relationship from A_ik and a relationship from A_kj. With the  definition of Avus number product and sum in the previous section, applying the Floyd-Warshall  algorithm to a matrix of Avus numbers results in the transitive closure, R^+. The example of R^+ above that was derived from inspection can now be computed by applying floyd_warshall_transitive_closure to the initial state, R.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Observe the following properties of R^+:","category":"page"},{"location":"","page":"Home","title":"Home","text":"row vectors represent the complete ancestry view for a given vertex\ncolumn vectors represent the complete descendancy view for a given vertex\nrow vectors representing siblings are nearly identical (they are independent due to every vertex having an edge to ","category":"page"},{"location":"","page":"Home","title":"Home","text":"itself)","category":"page"},{"location":"","page":"Home","title":"Home","text":"determining whether mathbfv is an ancestor of mathbfu, as well as the lineage path, is ","category":"page"},{"location":"","page":"Home","title":"Home","text":"mathcalO(1) and provided by R^+uv","category":"page"},{"location":"#Applications-of-R","page":"Home","title":"Applications of R^+","text":"","category":"section"},{"location":"#Determining-Ancestry-and-Lineage-Path-between-\\mathbf{v}-and-\\mathbf{u}","page":"Home","title":"Determining Ancestry and Lineage Path between mathbfv and mathbfu","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As noted in the observations above, this is a simple lookup in R^+. The resultant relationship value can be deconstructed (by reversing the shortest path walk described in the formal definition) to provide the lineage path.","category":"page"},{"location":"#Calculating-Relationship-Between-Two-Rows-in-R","page":"Home","title":"Calculating Relationship Between Two Rows in R^+","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With R^+ there exists an efficient way to determining full kinship (see:  consanguinity) between any two vertices. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given two row vectors from R^+, vec u and vec v, find the minimum of vec u_i + vec v_i where ","category":"page"},{"location":"","page":"Home","title":"Home","text":"both vec u_i and vec v_i are non-zero. This yields values, r(mathbfumathbfi) and  r(mathbfvmathbfi) expressing the relationship of mathbfu and mathbfv to the nearest common  ancestor, mathbfi_min","category":"page"},{"location":"","page":"Home","title":"Home","text":"Determine the path length from mathbf u and mathbf v to the common ancestor, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"log_2(r(mathbfumathbfi)) and log_2(r(mathbfvmathbfi)).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using a Table of Consanguinity, calculate the relationship","category":"page"},{"location":"","page":"Home","title":"Home","text":"Determining whether mathbfu is related to mathbfv is mathcalO(m) where m is the expected  number of ancestors and m  V (assuming an efficient sparse matrix representation). Empirically, m is on  the order of log_2(V).","category":"page"},{"location":"#Avus-Linear-Algebra","page":"Home","title":"Avus Linear Algebra","text":"","category":"section"},{"location":"#Introduction-2","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Having provided a formal definition for a Red Black Graph, looked at its adjacency matrix, R, the transitive closure of its adjacency matrix, R^+, and the avus sum and product, let's extend these observations into a more general discussion of how principles of linear algebra can be applied to Red Black Graphs.","category":"page"},{"location":"#Vector-Classes","page":"Home","title":"Vector Classes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Within the context of a Red Black Graph and its matrix representations, R and R^+, the following vector classes are defined:","category":"page"},{"location":"","page":"Home","title":"Home","text":"row vector - represented as vecmathbfu. These vectors represent ancestry for a given vertex. Values for elements in these vectors are constrained to avus numbers where any number, aside from 0, may appear in an alement at most once and where either colorred1 or 1 must appear as an element but not both. \ncolumn vector - represented by vecmathbfv. These vectors represent descendency for a given vertex. Values for elements in these vectors are constrained to avus numbers where either colorred1 or 1 must appear as an element but not both. Futhermore if colorred1 appears as an element any further non-zero integer elements must be even and if 1 appears as an element any further non-zero integer elements must be odd.\nsimple row vector - represented by vecmathbfu_s. Row vectors for which elements are constrained to {0, {\\color{red}1}, 1, 2, 3}. These represent a given vertex and it's immediate ancestry only.\nsimple column vector - represented by vecmathbfv_s. Column vectors for which elements are constrained to {0, {\\color{red}1}, 1, 2, 3}. These represent a given vertex and it's immediate descendency only.\nclosed row vector - represented by vecmathbfu_c. Row vectors from R^+. These represent the complete ancestry for a given vertex.\nclosed column vector - represented by vecmathbfv_c. Column vectors from R^+. These represent the complete descendency for a given vertex.\ncompositional vectors - represented by vecmathbfu^c_s or vecmathbfv^c_s. Compositional vectors conform to the constrainst of simple row or column vectors with the following additional constraint: neiter 1 nor {\\color{red}1} appear as an element. The color of the vector is inherent to the vector but not carried as an element. Any consraints due the color are present as if the color were present as an element. Color, if significant, is represented notationally by replacing the supersscript c with the color designation, either r or b.","category":"page"},{"location":"#Avus-Product-for-Vectors","page":"Home","title":"Avus Product for Vectors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider what an avus vector product might represent. Given a row vector and a column vector, the avus product is r(mathbfumathbfv), the relationship between the vertices representing the row and column vectors respectively. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider the R from the transitive closure example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginbmatrix\ncolorred1  2  3  0  0 \n0  colorred1  0  2  0 \n0  0  1  0  0 \n0  0  0  colorred1  0 \n2  0  0  0  1 \nendbmatrix","category":"page"},{"location":"","page":"Home","title":"Home","text":"The 4th row vector of R is vecmathbfu_s for vertex_4 while the 2nd column vector is vecmathbfv_s for vertex_2. It is observable by inspection that relationship of vertex_4 and vertex_2 is r(mathbfumathbfv) == 5 or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginbmatrix\n2  0  0  0  1 \nendbmatrix\n*\nbeginbmatrix\n3 \n0 \n1 \n0 \n0 \nendbmatrix\n= 5","category":"page"},{"location":"","page":"Home","title":"Home","text":"The vector dot product, summing element-wise products, results in a scaler value of 6. Avus summing of element-wise avus products does yield 5, which represents a relationship.","category":"page"},{"location":"#Observation-Simple/Complete-Relationship","page":"Home","title":"Observation - Simple/Complete Relationship","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The product of a simple row vector and the transitive closure of a Red Black adjacency matrix is a closed row vector vecmathbfu_s * R^+ = vecmathbfu_c","category":"page"},{"location":"","page":"Home","title":"Home","text":"The product of the transitive closure of a Red Black adjacency matrix and a simple column vector is a closed column vector R^+ * vecmathbfv_s = vecmathbfv_c","category":"page"},{"location":"","page":"Home","title":"Home","text":"TODO: Need to walk through an explanation of why this is so.","category":"page"},{"location":"#Avus-product-for-Matrices","page":"Home","title":"Avus product for Matrices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With scaler and vector avus products defined, extension to matrices is elementary. Given A and B, both matrices following the constraints defined for R, and C = A * B, the elements of C_ij are given by the vector avus product of mathbfu_i from A and mathbfv_j from B","category":"page"},{"location":"","page":"Home","title":"Home","text":"Avus matrix multiplication of general matrices seems a little abstract so consider the following practical example. R * R shows all vertices directly related by following up to 2 relationship edges, R * R *** R shows all vertices related by following up to 3 relationship edges, etc. For some m = V there will be a prod_n=1^m R == R^+.","category":"page"},{"location":"#Relational-Composition","page":"Home","title":"Relational Composition","text":"","category":"section"},{"location":"#Adding-a-Vertex-to-R","page":"Home","title":"Adding a Vertex to R^+","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Consider the case of adding a new vertex to a red black graph. The new vertex, lambda, may introduce edges to/from vertices in the graph and the corresponding row/column vectors conform to the compositional vector classes defined above. Specifically if adding a red vertex to the graph, the vectors mathbfu^r_lambdas and mathbfv^r_lambdas define the composition, or if adding a black vertex to the graph, the vectors mathbfu^b_lambdas and mathbfv^b_lambdas define the composition. These compositional vectors have non-zero elements only for immediate ancestry/descendency. The operation of adding a new vertex to a graph is designated the \"vertex relational composition\" and is defined where R^+ is a square matrix of dimension N and R_lambda^+ is a square matrix of dimension N + 1 and the colors of vecmathbfu^c_lambdas and vecmathbfv^c_lambdas must be the same. The notation of the vertex relational composition is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"R_lambda^+ = vecmathbfu^c_lambdas R^+ vecmathbfv^c_lambdas_color","category":"page"},{"location":"","page":"Home","title":"Home","text":"The simple/complete relationship observation above can be applied in this instance. vecmathbfu^c_lambdac = vecmathbfu^c_lambdas * R^+ and vecmathbfv^c_lambdac = R^+ * vecmathbfv^c_lambdas. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"vecmathbfu^c_lambdac","category":"page"},{"location":"","page":"Home","title":"Home","text":"and vecmathbfv^c_lambdac are the row and column, respectively, that need to be appended to R^+ (along with the final diagonal element corresponding to lambda's color) to compose R_lambda^+. Appending the complete compositional vectors to R^+ isn't sufficient to compose R_lambda^+. The \"body\" of R^+ needs to be \"updated\" to ensure that R_lambda^+ is also transitively closed. For each row in R^+, every element in that row is set to the avus product of the corresponding column element in vecmathbfv^c_lambdac and the corresponding row element in vecmathbfu^c_lambdac.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Expressing this algorithmically:","category":"page"},{"location":"","page":"Home","title":"Home","text":"generate vecmathbfu^c_lambdac = vecmathbfu^c_lambdas * R^+\ngenerate vecmathbfv^c_lambdac = R^+ * vecmathbfv^c_lambdas\nCompose R_lambda^+ by:\nappending mathbfu^c_lambdac to R^+ as a new row \nappending mathbfv^c_lambdac to R^+ as a new column\nsetting the diagnoal element R_lambda^+_N+1 N+1 to either 1 or colorred1 depending on the color of the composition.\nFor each row, i, and each column, j, where vecmathbfu^c_lambdac_j neq 0, set R_lambda^+_ij = vecmathbfu^c_lambdac_j * vecmathbfv^c_lambdac_i","category":"page"},{"location":"#Adding-an-Edge-to-R","page":"Home","title":"Adding an Edge to R^+","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[TODO: This notation is muddy. Need to rework this section]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider the case of adding a new edge to a red black graph. The operation of adding a new edge to a graph is designated the \"edge relational composition\". The new edge is added between two existing vertices, vertex_alpha and vertex_beta. The notation of the edge relational composition is:","category":"page"},{"location":"","page":"Home","title":"Home","text":"R^+_lambda = R^+ * r(mathbfalpha mathbfbeta)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As in the vertex relational composition, we'll make use of the simple/complete relational observation. In this case, the row representing vertex_alpha is replaced with the avus product of itself (with element_beta replaced with r(mathbfalpha mathbfbeta)) and R^+. Notationally: R^+ = R^+ +_alpha ((vertex_alpha +_beta r(mathbfalpha mathbfbeta)) * R^+) where +_i designates replacement of element i in the LHS with the value of the RHS. As in the vertex relational composition, replacing row vector alpha with it's complete form isn't sufficient to compose R_lambda^+. The remainder of the row vectors need to be closed with the new relationship. For each row, i, in R^+ excluding alpha, every element, j in that row is set to R^+_ialpha * R^+_alphaj.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Expressing this algorithmically:","category":"page"},{"location":"","page":"Home","title":"Home","text":"generate vecmathbfu^_alpha = vecmathbfu_alpha +_beta r(mathbfalphamathbfbeta), where vecmathbfu_alpha is row alpha in R^+\ngenerate vecmathbfu^c_alpha = vecmathbfu^_alpha * R^+\nCompose R_lambda^+ by:\nreplacing row alpha in R^+: R^+ = R^+ +_beta vecmathbfu^c_aalpha \nFor each row, i, and each column, j, where i neq alpha, set R_lambda^+_ij = R^+_ialpha * R^+_alphaj","category":"page"},{"location":"#Applications-of-Avus-Linear-Algebra","page":"Home","title":"Applications of Avus Linear Algebra","text":"","category":"section"},{"location":"#Loop-Prevention","page":"Home","title":"Loop Prevention","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An issue that can be encountered in systems that represent familial relationships is the inadvertent injection of graph cycles, resulting in the \"I am my own Grandpa\" case. While this is impossible when relationships model sexual reproduction, the introduction of step-relationships, etc. would make this a possibility. Often times there is ambiguity in the available historical records. If a researcher isn't careful, cylces may result as a genealogical model is created. Modifications to both forms of the relational composition algorithms can prevent the introduction of cycles into the graph. ","category":"page"},{"location":"#Vertex-Relational-Composition-Loop-Prevention","page":"Home","title":"Vertex Relational Composition Loop Prevention","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As vertices are added to an existing graph via relational composition, the intermedite, complete compositional vectors, vecmathbfu^c_lambda c and vecmathbfv^c_lambda s represent the complete ancestry and complete descedency for the new vertex lambda respectively. The cycle constraint would be invalidated should there be any vertex that simultaneously appears in the ancestry and descendency for a given vertex.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given vecmathbfu^c_lambda c and vecmathbfv^c_lambda s of dimension n, the vertex relational composition is undefined if there exists a dimension i where i neq n land vecmathbfu^c_lambda c_i neq 0 land vecmathbfv^c_lambda s_i neq 0 and is well-formed otherwise.","category":"page"},{"location":"#Edge-Relational-Composition-Loop-Prevention","page":"Home","title":"Edge Relational Composition Loop Prevention","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This case is trivial with a transitively closed matrix. Given R^+ and r(mathbfalphamathbfbeta), the edge relational composition is undefined if r(mathbfbetamathbfalpha) neq 0 and well-formed otherwise.","category":"page"},{"location":"#Connected-Component-Identification","page":"Home","title":"Connected Component Identification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[TODO: rework this section to tie together topological sort + component identification in a single DFS pass. This will be more efficient than current algorithm.]","category":"page"},{"location":"","page":"Home","title":"Home","text":"As Red Black Graphs are used to represent family relationships, an interesting case is determining how many disjoint trees are represetned within a graph. Tarjan's algorithm is typically used to compute the connected components of a graph. In the case of a transitively closed adjacency matrix, the depth first search used in Tarjan's algorithm is inherently \"pre-computed\". Because of this property, Tarjan's algorithm can be simplified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider the following graph","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Graph with Components)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By inspection, there are two components and the application of the simplified Tarjan's algorithm identifies which vertices belong to which components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"With an efficient sparse representation this algorithm is also mathbfO(V + E).","category":"page"},{"location":"#RedBlackGraph-Canonical-Form","page":"Home","title":"RedBlackGraph Canonical Form","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Returning to the example, it is obvious from inspection that one component consists of 4 nodes, the other of 3 and that the diamter of the larger component is 2, while the diamter of the smaller is 1. As this information is readily available in the Red Black Graph, it is easily added to the find_components algorithm (see the following find_components_extended algorithm). Observe thatsymetrically permuting a matrix corresponds to relabeling the vertices of the associated graph. I will show that with an appropriate relabeling of the graph vertices the Red Black graph adjacency matrix is upper triangular, R^+_c or canonical form. I will also show that R^+_c = mathbfP R^+ mathbfP^top where mathbfP is a permutation matrix derived from the count of the vertices in a component. mathbfP will be chosen such that R^+_c in addition to being upper triangular, each graph component and its diameter is readily identified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To arrive at mathbfP the list of nodes is sorted (in reverse order) first on the size of the encompassing connected component, secondly on the identifier of the connected component and finally on the maximum r(mathbfumathbfv) for the vertex. The vertices are then labeled based on this sorting, e.g. the zero^th vertex is the vetex from the largest connected component that has the greatest r(mathbfumathbfv) (or most distant ancestor) on down to the n^th vertex which is the vertex from the smallest connected component with no (or nearest) ancestor. (Ordering is arbitrary for vertices with identical sort keys.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple implementation of triangularizing R based on the properties inherent in the adjacency matrix and the extended find_components algorithm follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Graph with Components (Canonical Form))","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [RedBlackGraph]","category":"page"},{"location":"#RedBlackGraph.AInteger","page":"Home","title":"RedBlackGraph.AInteger","text":"AInteger (or Avus Integer)\n\nIntegers that follow Avus definition for addition and multiplication. AIntegers also have a distinct integer, colorred1, where:\n\n0  colorred1  1\niseven(colorred1) == true\n\n\n\n\n\n","category":"type"},{"location":"#RedBlackGraph.Relationship","page":"Home","title":"RedBlackGraph.Relationship","text":"struct Relationship\n\nA structure designed to capture the relationship between two individuals\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Tuple{AInteger, AInteger}","page":"Home","title":"Base.:*","text":"*(x::Integer, y::Integer)\n\nAvus Product or transitive relationship function.\n\nConsider 3 vertices: u, v and w. Furthermore, assume that there is a path from u to v, represented as x, and from v to w, represented as y.\n\nThe Avus Product provides the path from u to w, represented as z, e.g. z = x ⨰ y\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{AInteger, AInteger}","page":"Home","title":"Base.:+","text":"+(x::Integer, y::Integer)\n\nAvus Sum or min(x, y) where min(0) == ∞ and colorred1  1.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:<-Tuple{AInteger, AInteger}","page":"Home","title":"Base.:<","text":"<(x::AInteger, y::AInteger)\n\nfor comparison purpose, 0 compares as ∞ and colorred1 is the least value of any AInteger\n\n\n\n\n\n","category":"method"},{"location":"#Base.iseven-Tuple{AInteger}","page":"Home","title":"Base.iseven","text":"iseven(x::AInteger) -> Bool\n\nReturn true if x is even (that is, divisible by 2) or colorred1, and false otherwise.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"#RedBlackGraph.floyd_warshall_transitive_closure-Union{Tuple{Matrix{A}}, Tuple{A}} where A<:AInteger","page":"Home","title":"RedBlackGraph.floyd_warshall_transitive_closure","text":"floyd_warshall_transitive_closure(g)\n\nUse the Floyd-Warshall algorithm to compute the transistive closure of a redblackgraph g. Return a Matrix{AInteger} that represents the transitive closure of the redblackgraph adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"#RedBlackGraph.lookup_relationship-Tuple{Integer, Integer}","page":"Home","title":"RedBlackGraph.lookup_relationship","text":"lookup_relationship(AInteger, AInteger)\n\nGiven two individuals with a common ancestor where the first parameter is the generational distance from the first individual to the common ancestor and the second parameter is the generational distance from the second individual to the common ancestor, this function provides a string representation of how the two individuals are related.\n\n\n\n\n\n","category":"method"},{"location":"#RedBlackGraph.read_graph","page":"Home","title":"RedBlackGraph.read_graph","text":"read_graph(dir::String, name::String, sparse_size_threshold = 10000)\n\nA utility to parse input csv files into a RedBlackGraph. The first argument is the directory that holds the csv files.\nThe second is the basename for the csv files. By convention, there are two csv files <basename>.canonical.edges.csv and \n<basename>.canonical.vertices.csv. \n\n<basename>.canonical.edges.csv may have more than two columns, but the first two are significant for these utilities.\nColumn 1 is the source vetex number, Column 2 is the destination vertex number.\n\n<basename>.canonical.vertices.csv may have more than 2 columns, but two are significant for these utilites. It must contain\na Column labeled \"vertex_number\" and one labeled \"color\". Both columns contain integers.\n\nThis utility will return either a Matrix{AInt64} or a SparseMatrixCSC{AInt64, Int64} if the number of vertices in the graph\nis greater than the value of sparse_size_threshold.\n\n(Note: https://github.com/rappdw/fs-crawler can be used to generate the required csv files.)\n\n\n\n\n\n","category":"function"},{"location":"#RedBlackGraph.red_one-Tuple{AInteger}","page":"Home","title":"RedBlackGraph.red_one","text":"red_one(x)\nred_one(T::type)\n\nReturn a colorred1 for x: a value such that colorred1 + 1 == colorred1.\n\n\n\n\n\n","category":"method"}]
}
