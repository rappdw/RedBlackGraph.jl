<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · RedBlackGraph.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://rappdw.github.io/RedBlackGraph.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>RedBlackGraph.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Formal-Definition"><span>Formal Definition</span></a></li><li><a class="tocitem" href="#RedBlackGraph-Adjacency-Matrices-and-Avus-Arithmetic"><span>RedBlackGraph Adjacency Matrices and Avus Arithmetic</span></a></li><li><a class="tocitem" href="#Applications-of-R"><span>Applications of <span>$R^+$</span></span></a></li><li><a class="tocitem" href="#Avus-Linear-Algebra"><span>Avus Linear Algebra</span></a></li><li><a class="tocitem" href="#Relational-Composition"><span>Relational Composition</span></a></li><li><a class="tocitem" href="#Applications-of-Avus-Linear-Algebra"><span>Applications of Avus Linear Algebra</span></a></li><li><a class="tocitem" href="#RedBlackGraph-Canonical-Form"><span>RedBlackGraph Canonical Form</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rappdw/RedBlackGraph.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="RedBlackGraph.jl"><a class="docs-heading-anchor" href="#RedBlackGraph.jl">RedBlackGraph.jl</a><a id="RedBlackGraph.jl-1"></a><a class="docs-heading-anchor-permalink" href="#RedBlackGraph.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/rappdw/RedBlackGraph.jl">RedBlackGraph</a>. RedBlackGraphs are DAGs of interleaved Binary Trees.</p><ul><li><a href="#RedBlackGraph.AInteger"><code>RedBlackGraph.AInteger</code></a></li><li><a href="#RedBlackGraph.Relationship"><code>RedBlackGraph.Relationship</code></a></li><li><a href="#Base.:*-Tuple{AInteger, AInteger}"><code>Base.:*</code></a></li><li><a href="#Base.:+-Tuple{AInteger, AInteger}"><code>Base.:+</code></a></li><li><a href="#Base.:&lt;-Tuple{AInteger, AInteger}"><code>Base.:&lt;</code></a></li><li><a href="#Base.iseven-Tuple{AInteger}"><code>Base.iseven</code></a></li><li><a href="#RedBlackGraph.floyd_warshall_transitive_closure-Union{Tuple{Matrix{A}}, Tuple{A}} where A&lt;:AInteger"><code>RedBlackGraph.floyd_warshall_transitive_closure</code></a></li><li><a href="#RedBlackGraph.lookup_relationship-Tuple{Integer, Integer}"><code>RedBlackGraph.lookup_relationship</code></a></li><li><a href="#RedBlackGraph.red_one-Tuple{AInteger}"><code>RedBlackGraph.red_one</code></a></li></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>When representing binary relationships, such as familial relationships, a number of approaches may be utilized including: ad-hoc, general graphs, specialized tables or charts. As I&#39;ve explored different representations, a specialized mathematical representation has emerged. This mathematical representation is useful as the underpinnings of dynamic graph algorithms for use cases that include graph analysis, relationship calculation, loop detection, loop prevention, etc.</p><p>The underlying mathematical model is a directed, acyclic graph of multiple, interleaved binary trees, designated as a RedBlackGraph. The name, RedBlackGraph, derives from superficial similarity to Red Black Trees. Red Black Trees are binary trees such that each node has an extra, color bit (red or black). This color bit is used to balance the tree as modifications are made. In a RedBlackGraph each vertex also has an extra, color bit, rather than utilizing the color bit for balancing, the color bit is used to constrain edges between vertices.</p><p>I will provide a formal definition of a RedBlackGraph, as well as explore a number of interesting emergent properties. I will also examine several applications of RedBlackGraphs to illustrate the utility of using this mathematical model for familial relationships.</p><h2 id="Formal-Definition"><a class="docs-heading-anchor" href="#Formal-Definition">Formal Definition</a><a id="Formal-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Formal-Definition" title="Permalink"></a></h2><p>A RedBlackGraph is a network, <span>$\mathscr{N}$</span>, consisting of a directed graph, <span>$G = (V,E)$</span>, and a relationship function, <span>$r(\mathbf{u},\mathbf{v})\rightarrow \{\mathbb{A}\}$</span>. Where:</p><ol><li><span>$\mathbb{A}$</span>, Avus numbers, are: <span>$\mathbb{N} \cup \{0, {\color{red}1}\}$</span> <span>$\text{where: }\begin{cases} {\color{red}1} \lt 1, \\ {\color{red}1} \text{ is even}, \\ \text{otherwise }{\color{red}1} \text{ behaves as }1 \end{cases}$</span></li><li>Any given vertex must have a color, either red or black</li><li>Any given vertex can have at most one outbound edge to a vertex of a given color</li><li>Every vertex has an edge to itself where: <span>$r(\mathbf{v},\mathbf{v})\rightarrow \begin{cases} {\color{red}1}, &amp; \text{if }{\mathbf{v}} \text{ is a red vertex}, \\1, &amp; \text{if }\mathbf{v}\text{ is a black vertex} \end{cases}$</span></li><li>If there is no path in <span>$G$</span> from <span>$\mathbf{u}$</span> to <span>$\mathbf{v}$</span>, <span>$r(\mathbf{u},\mathbf{v})\rightarrow 0$</span></li><li>For all other <span>$\mathbf{u}$</span>, <span>$\mathbf{v}$</span> not covered by constraints 4 and 5, <span>$r(\mathbf{u},\mathbf{v})\rightarrow x$</span>, were <span>$x$</span> is generated by walking the shortest path (assume uniform edge weights) from <span>$\mathbf{u}$</span> to <span>$\mathbf{v}$</span> as follows:<ol><li><span>$x \leftarrow 1$</span></li><li>walk the edge along the shortest path and update <span>$x$</span> as follows: <span>$x \leftarrow \begin{cases} x \ll 0, &amp; \text{if resultant vertex is red}, \\ x \ll 1, &amp; \text{if resultant vertex is black} \end{cases}$</span> (<span>$\ll$</span> is bitwise shift left)</li><li>repeat step two until <span>$\mathbf{v}$</span> is reached</li></ol></li></ol><p>(Note: a new class of numbers are defined, Avus numbers, as above. Avus, in Latin, refers to ancestors. As this number system is derived from working on representing ancestry, the name seems appropriate.)</p><h3 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h3><p>The relationships resulting from sexual reproduction can be modeled by a RedBlackGraph, arbitrarily assigning vertices that are male as Red and vertices that are female as Black with direction of edges being from the offspring to the parent.</p><p><img src="assets/img/simple-graph.png" alt="simple-graph"/></p><h3 id="Observation"><a class="docs-heading-anchor" href="#Observation">Observation</a><a id="Observation-1"></a><a class="docs-heading-anchor-permalink" href="#Observation" title="Permalink"></a></h3><p>For a given vertex in a RedBlackGraph there are two distinct sub-graphs or &quot;views&quot; or perspectives, for a given vertex: Descendancy and Ancestry.</p><p><strong>Descendancy</strong> is the sub-graph for a given vertex that consists of all vertices and edges that can follow a graph traversal and arrive at the given node.</p><p><img src="assets/img/simple-graph-descendancy.png" alt="simple-graph-descendancy"/></p><p><strong>Ancestry</strong> is the sub-graph for a given vertex that consists of all the vertices and edges reachable by following out-bound edges. This sub-graph is a well-formed binary tree.</p><p><img src="assets/img/simple-graph-ancestry.png" alt="simple-graph-ancestry"/></p><p>The Ancestry sub-graph from a given <span>$\mathbf{u}$</span> is a well-formed binary tree. <span>$r(\mathbf{u},\mathbf{v})$</span> is defined as to number the nodes of the tree as they are encountered in a breadth first search. A concrete example of <span>$r(\mathbf{u},\mathbf{v})$</span> is observed in a pedigree chart (common in family history research). See fig. Pedigree Chart.</p><p><img src="assets/img/pedigree-1.png" alt="pedigree"/></p><h2 id="RedBlackGraph-Adjacency-Matrices-and-Avus-Arithmetic"><a class="docs-heading-anchor" href="#RedBlackGraph-Adjacency-Matrices-and-Avus-Arithmetic">RedBlackGraph Adjacency Matrices and Avus Arithmetic</a><a id="RedBlackGraph-Adjacency-Matrices-and-Avus-Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#RedBlackGraph-Adjacency-Matrices-and-Avus-Arithmetic" title="Permalink"></a></h2><h3 id="Adjacency-Matrix"><a class="docs-heading-anchor" href="#Adjacency-Matrix">Adjacency Matrix</a><a id="Adjacency-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Adjacency-Matrix" title="Permalink"></a></h3><p>An adjacency matrix is a square matrix used to represent a graph. The elements of the matrix are 1 (or edge weight) if there is an edge between the vertices represented by the column index and the row index. Slightly more formally, for <span>$G$</span> with a vertex set <span>$V$</span>, the adjacency matrix is a square <span>$|V|$</span> x <span>$|V|$</span> matrix, <span>$A$</span> such that <span>$A_{ij}$</span> is <span>$1$</span> if there exists an edge from <span>$\mathbf{i}$</span> to <span>$\mathbf{j}$</span> and <span>$0$</span> otherwise.</p><p>Given the above example graph and choosing indices for the vertices as follows: 0 - Female Offspring, 1 - Male Offspring, 2 - Male Progenitor, 3 - Female Progenitor, the graph would be represented by the following adjacency matrix.</p><p class="math-container">\[A = \begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{bmatrix}\]</p><h3 id="RedBlackGraph-Adjacency-Matrix"><a class="docs-heading-anchor" href="#RedBlackGraph-Adjacency-Matrix">RedBlackGraph Adjacency Matrix</a><a id="RedBlackGraph-Adjacency-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#RedBlackGraph-Adjacency-Matrix" title="Permalink"></a></h3><p>Let&#39;s define the adjacency matrix for a RedBlackGraph only slightly differently. <span>$R_{ij}=r(\mathbf{i}, \mathbf{j})$</span> if there is a relationship from <span>$\mathbf{i}$</span> to <span>$\mathbf{j}$</span> and <span>$0$</span> otherwise. The following is the RedBlackGraph adjacency matrix for the above example graph.</p><p class="math-container">\[R = \begin{bmatrix} 1 &amp; 0 &amp; 2 &amp; 3 \\ 0 &amp; {\color{red}1} &amp; 2 &amp; 3 \\ 0 &amp; 0 &amp; {\color{red}1} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}\]</p><p>Observe the following properties:</p><p><span>$trace(R) = |V_{black}| - |V_{red}|$</span></p><p><span>$|V| = |V_{black}| + |V_{red}|$</span></p><p><span>$|V_{black}| = \frac{|V| + trace(R)}{2}$</span></p><p><span>$|V_{red}| = \frac{|V| - trace(R)}{2}$</span></p><h3 id="Transitive-Closure"><a class="docs-heading-anchor" href="#Transitive-Closure">Transitive Closure</a><a id="Transitive-Closure-1"></a><a class="docs-heading-anchor-permalink" href="#Transitive-Closure" title="Permalink"></a></h3><p>Computing the transitive closure of an adjacency matrix, <span>$A$</span>, results in the reachability a matrix, <span>$A^+$</span>, that shows all vertices that are reachable from any given vertex. If <span>$A_{ij} == 1$</span> there is a path from <span>$\mathbf{v}_i$</span> to <span>$\mathbf{v}_j$</span>.</p><p>The transitive closure of a RedBlackGraph adjacency matrix, <span>$R$</span>, is defined to be the relationship matrix, <span>$R^+$</span>. In addition to reachability, <span>$R^+$</span> is defined in such that if <span>$R^+_{ij} == \mathbf{n}$</span> and <span>$\mathbf{n}$</span> is non-zero, then from <span>$\mathbf{n}$</span> we can derive both the path length and the explicit traversal path from <span>$\mathbf{i}$</span> to <span>$\mathbf{j}$</span>.</p><p>As an example consider the following graph, where each node has been labeled with a vertex index:</p><p><img src="assets/img/simple-graph-transitive-closure.png" alt="simple-graph-transitive-closure"/></p><p>By inspection:</p><p class="math-container">\[R = \begin{bmatrix} {\color{red}1} &amp; 2 &amp; 3 &amp; 0 &amp; 0 \\ 0 &amp; {\color{red}1} &amp; 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0
&amp; {\color{red}1} &amp; 0 \\ 2 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\text{ and }R^+ = \begin{bmatrix} {\color{red}1} &amp; 2 &amp; 3 &amp; 4 &amp;
0 \\ 0 &amp; {\color{red}1} &amp; 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; {\color{red}1} &amp; 0 \\ 2 &amp; 4 &amp; 5 &amp; 8 &amp; 1 \\
\end{bmatrix}\]</p><p>Before examining how to generate <span>$R^+$</span> from <span>$R$</span>, consider the following observations:</p><ul><li><span>$r(\mathbf{u},\mathbf{v})$</span> is even when <span>$\mathbf{v}$</span> is red and odd when black. (By convention <span>${\color{red}1}$</span> is considered even.)</li><li>The path length is inherent in <span>$r(\mathbf{u},\mathbf{v})$</span>, and is trivially derived by taking the integral portion of <span>$log_{2}(r(\mathbf{u},\mathbf{v}))$</span>.</li><li>The traversal path is also inherent in <span>$r(\mathbf{u},\mathbf{v})$</span> and can be derived by reversing <span>$r$</span>&#39;s definition and successively right shifting out bits (of a <span>$base_2$</span> integer representation) and using that bit to &quot;walk&quot; the traversal edge to a red vertex or black vertex.</li><li>The diameter of <span>$R^+$</span> is given by <span>$log_{2}(max(r(\mathbf{u},\mathbf{v})))$</span>.</li></ul><h3 id="Avus-Arithmetic"><a class="docs-heading-anchor" href="#Avus-Arithmetic">Avus Arithmetic</a><a id="Avus-Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Avus-Arithmetic" title="Permalink"></a></h3><p>As constructing <span>$R^+$</span> by inspection is cumbersome for non-trivial cases, let&#39;s explore a method to algorithmically derive <span>$R^+$</span> from <span>$R$</span>.</p><h4 id="Transitive-Relationship-Function-or-Avus-Product"><a class="docs-heading-anchor" href="#Transitive-Relationship-Function-or-Avus-Product">Transitive Relationship Function or Avus Product</a><a id="Transitive-Relationship-Function-or-Avus-Product-1"></a><a class="docs-heading-anchor-permalink" href="#Transitive-Relationship-Function-or-Avus-Product" title="Permalink"></a></h4><p>The first step requires defining a transitive relationship function. To illustrate, consider 3 vertices: <span>$\mathbf{u}$</span> , <span>$\mathbf{v}$</span> and <span>$\mathbf{w}$</span>. Further, assume that there is a path from <span>$\mathbf{u}$</span> to <span>$\mathbf{v}$</span> and from <span>$\mathbf{v}$</span> to <span>$\mathbf{w}$</span>. I&#39;ll define the function, <span>$f(r(\mathbf{u},\mathbf{v}),r(\mathbf{v},\mathbf{w}))\rightarrow r(\mathbf{u},\mathbf{w})$</span>, as the <em>avus product</em>, e.g. <span>$r(\mathbf{u},\mathbf{w})=r(\mathbf{u},\mathbf{v}) * r(\mathbf{v},\mathbf{w})$</span>.</p><p>If <span>$r(\mathbf{u},\mathbf{v})=4$</span> (<span>$\mathbf{v}$</span> is <span>$\mathbf{u}$</span>&#39;s paternal grandfather) and <span>$r(\mathbf{v},\mathbf{w})=7$</span> (<span>$\mathbf{w}$</span> is <span>$\mathbf{v}$</span>&#39;s maternal grandmother). Using either the definition of <span>$r$</span> or transcribing <span>$\mathbf{v}$</span>&#39;s pedigree into the proper place in <span>$\mathbf{u}$</span>&#39;s pedigree chart we see that <span>$r(\mathbf{u},\mathbf{w})=19$</span>, or <span>$19 = 4 * 7$</span>. To further explore this, consider the following (<span>$r(\mathbf{x},\mathbf{y})$</span> represented in base-2 for illustrative purposes):</p><table><tr><th style="text-align: right"><span>$\mathbf{v}$</span>&#39;s relationship to <span>$\mathbf{u}$</span></th><th style="text-align: right"><span>$\mathbf{w}$</span>&#39;s relationship to <span>$\mathbf{v}$</span></th><th style="text-align: right"><span>$r(\mathbf{u},\mathbf{v})$</span></th><th style="text-align: right"><span>$r(\mathbf{v},\mathbf{w})$</span></th><th style="text-align: right"><span>$r(\mathbf{u},\mathbf{w})$</span></th></tr><tr><td style="text-align: right">father</td><td style="text-align: right">father</td><td style="text-align: right">10</td><td style="text-align: right">10</td><td style="text-align: right">100</td></tr><tr><td style="text-align: right">father</td><td style="text-align: right">mother</td><td style="text-align: right">10</td><td style="text-align: right">11</td><td style="text-align: right">101</td></tr><tr><td style="text-align: right">mother</td><td style="text-align: right">father</td><td style="text-align: right">11</td><td style="text-align: right">10</td><td style="text-align: right">110</td></tr><tr><td style="text-align: right">mother</td><td style="text-align: right">mother</td><td style="text-align: right">11</td><td style="text-align: right">11</td><td style="text-align: right">111</td></tr><tr><td style="text-align: right">father</td><td style="text-align: right">paternal grandfather</td><td style="text-align: right">10</td><td style="text-align: right">100</td><td style="text-align: right">1000</td></tr><tr><td style="text-align: right">maternal grandmother</td><td style="text-align: right">paternal grandfather</td><td style="text-align: right">111</td><td style="text-align: right">100</td><td style="text-align: right">11100</td></tr></table><p>To complete the definition of the Avus Product, the following conventions are imposed:</p><ol><li><span>${\color{red}1} = {\color{red}1} * 1$</span></li><li><span>${\color{red}1} = 1 * {\color{red}1}$</span></li><li>For all other cases, <span>${\color{red}1}$</span> is treated as <span>$1$</span></li></ol><h4 id="Avus-Sum"><a class="docs-heading-anchor" href="#Avus-Sum">Avus Sum</a><a id="Avus-Sum-1"></a><a class="docs-heading-anchor-permalink" href="#Avus-Sum" title="Permalink"></a></h4><p>It is natural to pair multiplication with addition for linear algebra operations (matrix multiplication, matrix distance product, etc.) a min-Avus product pairing conforms to the definition of RedBlackGraphs with a slight modification required for implementation in a typical RAM computer, namely <span>${\color{red}1}=2^\mathbf{w}-1$</span>, where <span>$\mathbf{w}$</span> is the word size of the numeric type. Aside from <span>${\color{red}1}$</span>, the range of <span>$r(\mathbf{u},\mathbf{v})$</span> is <span>$\mathbb{N}$</span>. It is therefore, natural to utilize unsigned numeric types to represent Avus numbers. Additionally, assume the convention <span>$min(0)=\infty$</span>. The min function needs to be aware of both these conventions. These conventions define <span>$Avus sum$</span>, e.g. <span>${\color{red}1} = {\color{red}1} + 5$</span> and <span>$2 = 37 + 2$</span> and <span>$3 = 0 + 3$</span>.</p><p>To complete the definition of the Avus Sum, the following conventions are imposed:</p><ol><li><span>${\color{red}1} = {\color{red}1} + 1$</span></li><li><span>${\color{red}1} = 1 + {\color{red}1}$</span></li><li>For all other cases, <span>${\color{red}1}$</span> is treated as <span>$1$</span></li></ol><h3 id="Transitive-Closure-for-RedBlackGraph-Adjacency-Matrix"><a class="docs-heading-anchor" href="#Transitive-Closure-for-RedBlackGraph-Adjacency-Matrix">Transitive Closure for RedBlackGraph Adjacency Matrix</a><a id="Transitive-Closure-for-RedBlackGraph-Adjacency-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Transitive-Closure-for-RedBlackGraph-Adjacency-Matrix" title="Permalink"></a></h3><p>Transitive closure of an adjacency matrix can be computed a number of ways, a simple approach is the  <a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd-Warshall Algorithm</a>.</p><p>Summarized, this algorithm is a tripple loop across the matrix indices continuously updating the current transitive  relationship, <span>$A^+_{i,j}$</span>, if there is a relationship from <span>$A_{i,k}$</span> and a relationship from <span>$A_{k,j}$</span>. With the  definition of Avus number product and sum in the previous section, applying the Floyd-Warshall  algorithm to a matrix of Avus numbers results in the transitive closure, <span>$R^+$</span>. The example of <span>$R^+$</span> above that was derived from inspection can now be computed by applying <code>floyd_warshall_transitive_closure</code> to the initial state, <span>$R$</span>.</p><p>Observe the following properties of <span>$R^+$</span>:</p><ul><li>row vectors represent the complete ancestry view for a given vertex</li><li>column vectors represent the complete descendancy view for a given vertex</li><li>row vectors representing siblings are nearly identical (they are independent due to every vertex having an edge to </li></ul><p>itself)</p><ul><li>determining whether <span>$\mathbf{v}$</span> is an ancestor of <span>$\mathbf{u}$</span>, as well as the lineage path, is </li></ul><p><span>$\mathcal{O}(1)$</span> and provided by <span>$R^+[u,v]$</span></p><h2 id="Applications-of-R"><a class="docs-heading-anchor" href="#Applications-of-R">Applications of <span>$R^+$</span></a><a id="Applications-of-R-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-of-R" title="Permalink"></a></h2><h3 id="Determining-Ancestry-and-Lineage-Path-between-\\mathbf{v}-and-\\mathbf{u}"><a class="docs-heading-anchor" href="#Determining-Ancestry-and-Lineage-Path-between-\\mathbf{v}-and-\\mathbf{u}">Determining Ancestry and Lineage Path between <span>$\mathbf{v}$</span> and <span>$\mathbf{u}$</span></a><a id="Determining-Ancestry-and-Lineage-Path-between-\\mathbf{v}-and-\\mathbf{u}-1"></a><a class="docs-heading-anchor-permalink" href="#Determining-Ancestry-and-Lineage-Path-between-\\mathbf{v}-and-\\mathbf{u}" title="Permalink"></a></h3><p>As noted in the observations above, this is a simple lookup in <span>$R^+$</span>. The resultant relationship value can be deconstructed (by reversing the shortest path walk described in the formal definition) to provide the lineage path.</p><h3 id="Calculating-Relationship-Between-Two-Rows-in-R"><a class="docs-heading-anchor" href="#Calculating-Relationship-Between-Two-Rows-in-R">Calculating Relationship Between Two Rows in <span>$R^+$</span></a><a id="Calculating-Relationship-Between-Two-Rows-in-R-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-Relationship-Between-Two-Rows-in-R" title="Permalink"></a></h3><p>With <span>$R^+$</span> there exists an efficient way to determining full kinship (see:  <a href="https://en.wikipedia.org/wiki/Consanguinity">consanguinity</a>) between any two vertices. </p><ol><li>Given two row vectors from <span>$R^+$</span>, <span>$\vec u$</span> and <span>$\vec v$</span>, find the minimum of <span>$\vec u_{i} + \vec v_{i}$</span> where </li></ol><p>both <span>$\vec u_{i}$</span> and <span>$\vec v_{i}$</span> are non-zero. This yields values, <span>$r(\mathbf{u},\mathbf{i})$</span> and  <span>$$r(\mathbf{v},\mathbf{i})$</span> expressing the relationship of <span>$\mathbf{u}$</span> and <span>$\mathbf{v}$</span> to the nearest common  ancestor, <span>$\mathbf{i_{min}}$</span></p><ol><li>Determine the path length from <span>$\mathbf u$</span> and <span>$\mathbf v$</span> to the common ancestor, </li></ol><p><span>$log_2(r(\mathbf{u},\mathbf{i}))$</span> and <span>$log_2(r(\mathbf{v},\mathbf{i}))$</span>.</p><ol><li>Using a Table of Consanguinity, calculate the relationship</li></ol><p>Determining whether <span>$\mathbf{u}$</span> is related to <span>$\mathbf{v}$</span> is <span>$\mathcal{O}(m)$</span> where <span>$m$</span> is the expected  number of ancestors and <span>$m &lt;&lt; |V|$</span> (assuming an efficient sparse matrix representation). Empirically, <span>$m$</span> is on  the order of <span>$log_2(|V|)$</span>.</p><h2 id="Avus-Linear-Algebra"><a class="docs-heading-anchor" href="#Avus-Linear-Algebra">Avus Linear Algebra</a><a id="Avus-Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Avus-Linear-Algebra" title="Permalink"></a></h2><h3 id="Introduction-2"><a class="docs-heading-anchor" href="#Introduction-2">Introduction</a><a class="docs-heading-anchor-permalink" href="#Introduction-2" title="Permalink"></a></h3><p>Having provided a formal definition for a Red Black Graph, looked at its adjacency matrix, <span>$R$</span>, the transitive closure of its adjacency matrix, <span>$R^+$</span>, and the avus sum and product, let&#39;s extend these observations into a more general discussion of how principles of linear algebra can be applied to Red Black Graphs.</p><h3 id="Vector-Classes"><a class="docs-heading-anchor" href="#Vector-Classes">Vector Classes</a><a id="Vector-Classes-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Classes" title="Permalink"></a></h3><p>Within the context of a Red Black Graph and its matrix representations, <span>$R$</span> and <span>$R^+$</span>, the following vector classes are defined:</p><ul><li><em>row</em> vector - represented as <span>$\vec{\mathbf{u}}$</span>. These vectors represent ancestry for a given vertex. Values for elements in these vectors are constrained to avus numbers where any number, aside from 0, may appear in an alement at most once and where either <span>${\color{red}1}$</span> or 1 must appear as an element but not both. </li><li><em>column</em> vector - represented by <span>$\vec{\mathbf{v}}$</span>. These vectors represent descendency for a given vertex. Values for elements in these vectors are constrained to avus numbers where either <span>${\color{red}1}$</span> or 1 must appear as an element but not both. Futhermore if <span>${\color{red}1}$</span> appears as an element any further non-zero integer elements must be even and if 1 appears as an element any further non-zero integer elements must be odd.</li><li><em>simple row vector</em> - represented by <span>$\vec{\mathbf{u}_{s}}$</span>. Row vectors for which elements are constrained to {0, {\color{red}1}, 1, 2, 3}. These represent a given vertex and it&#39;s immediate ancestry only.</li><li><em>simple column vector</em> - represented by <span>$\vec{\mathbf{v}_{s}}$</span>. Column vectors for which elements are constrained to {0, {\color{red}1}, 1, 2, 3}. These represent a given vertex and it&#39;s immediate descendency only.</li><li><em>closed row vector</em> - represented by <span>$\vec{\mathbf{u}_{c}}$</span>. Row vectors from <span>$R^+$</span>. These represent the complete ancestry for a given vertex.</li><li><em>closed column vector</em> - represented by <span>$\vec{\mathbf{v}_{c}}$</span>. Column vectors from <span>$R^+$</span>. These represent the complete descendency for a given vertex.</li><li><em>compositional vectors</em> - represented by <span>$\vec{\mathbf{u}^{c}_{s}}$</span> or <span>$\vec{\mathbf{v}^{c}_{s}}$</span>. Compositional vectors conform to the constrainst of simple row or column vectors with the following additional constraint: neiter 1 nor {\color{red}1} appear as an element. The color of the vector is inherent to the vector but not carried as an element. Any consraints due the color are present as if the color were present as an element. Color, if significant, is represented notationally by replacing the supersscript <span>$c$</span> with the color designation, either <span>$r$</span> or <span>$b$</span>.</li></ul><h3 id="Avus-Product-for-Vectors"><a class="docs-heading-anchor" href="#Avus-Product-for-Vectors">Avus Product for Vectors</a><a id="Avus-Product-for-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Avus-Product-for-Vectors" title="Permalink"></a></h3><p>Consider what an avus vector product might represent. Given a row vector and a column vector, the avus product is <span>$r(\mathbf{u},\mathbf{v})$</span>, the relationship between the vertices representing the row and column vectors respectively. </p><p>Consider the <span>$R$</span> from the transitive closure example:</p><p class="math-container">\[\begin{bmatrix}
{\color{red}1} &amp; 2 &amp; 3 &amp; 0 &amp; 0 \\
0 &amp; {\color{red}1} &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; {\color{red}1} &amp; 0 \\
2 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}\]</p><p>The 4th row vector of <span>$R$</span> is <span>$\vec{\mathbf{u}_{s}}$</span> for <span>$vertex_{4}$</span> while the 2nd column vector is <span>$\vec{\mathbf{v}_{s}}$</span> for <span>$vertex_{2}$</span>. It is observable by inspection that relationship of <span>$vertex_{4}$</span> and <span>$vertex_{2}$</span> is <span>$r(\mathbf{u},\mathbf{v}) == 5$</span> or:</p><p class="math-container">\[\begin{bmatrix}
2 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
*
\begin{bmatrix}
3 \\
0 \\
1 \\
0 \\
0 \\
\end{bmatrix}
= 5\]</p><p>The vector dot product, summing element-wise products, results in a scaler value of 6. Avus summing of element-wise avus products does yield 5, which represents a relationship.</p><h3 id="Observation-Simple/Complete-Relationship"><a class="docs-heading-anchor" href="#Observation-Simple/Complete-Relationship">Observation - Simple/Complete Relationship</a><a id="Observation-Simple/Complete-Relationship-1"></a><a class="docs-heading-anchor-permalink" href="#Observation-Simple/Complete-Relationship" title="Permalink"></a></h3><p>The product of a simple row vector and the transitive closure of a Red Black adjacency matrix is a closed row vector <span>$\vec{\mathbf{u}_{s}} * R^+ = \vec{\mathbf{u}_{c}}$</span></p><p>The product of the transitive closure of a Red Black adjacency matrix and a simple column vector is a closed column vector <span>$R^+ * \vec{\mathbf{v}_{s}} = \vec{\mathbf{v}_{c}}$</span></p><p><strong>TODO</strong>: Need to walk through an explanation of why this is so.</p><h3 id="Avus-product-for-Matrices"><a class="docs-heading-anchor" href="#Avus-product-for-Matrices">Avus product for Matrices</a><a id="Avus-product-for-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Avus-product-for-Matrices" title="Permalink"></a></h3><p>With scaler and vector avus products defined, extension to matrices is elementary. Given <span>$A$</span> and <span>$B$</span>, both matrices following the constraints defined for <span>$R$</span>, and <span>$C = A * B$</span>, the elements of <span>$C_{ij}$</span> are given by the vector avus product of <span>$\mathbf{u}_{i}$</span> from A and <span>$\mathbf{v}_{j}$</span> from B</p><p>Avus matrix multiplication of general matrices seems a little abstract so consider the following practical example. <span>$R * R$</span> shows all vertices directly related by following up to 2 relationship edges, <span>$R * R *** R$</span> shows all vertices related by following up to 3 relationship edges, etc. For some <span>$m &lt;= |V|$</span> there will be a <span>$\prod_{n=1}^{m} R == R^+$</span>.</p><h2 id="Relational-Composition"><a class="docs-heading-anchor" href="#Relational-Composition">Relational Composition</a><a id="Relational-Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Relational-Composition" title="Permalink"></a></h2><h3 id="Adding-a-Vertex-to-R"><a class="docs-heading-anchor" href="#Adding-a-Vertex-to-R">Adding a Vertex to <span>$R^+$</span></a><a id="Adding-a-Vertex-to-R-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-Vertex-to-R" title="Permalink"></a></h3><p>Consider the case of adding a new vertex to a red black graph. The new vertex, <span>$\lambda$</span>, may introduce edges to/from vertices in the graph and the corresponding row/column vectors conform to the compositional vector classes defined above. Specifically if adding a red vertex to the graph, the vectors <span>$\mathbf{u}^{r}_{\lambda,s}$</span> and <span>$\mathbf{v}^{r}_{\lambda,s}$</span> define the composition, or if adding a black vertex to the graph, the vectors <span>$\mathbf{u}^{b}_{\lambda,s}$</span> and <span>$\mathbf{v}^{b}_{\lambda,s}$</span> define the composition. These compositional vectors have non-zero elements only for immediate ancestry/descendency. The operation of adding a new vertex to a graph is designated the &quot;vertex relational composition&quot; and is defined where <span>$R^+$</span> is a square matrix of dimension <span>$N$</span> and <span>$R_{\lambda}^+$</span> is a square matrix of dimension <span>$N + 1$</span> and the colors of <span>$\vec{\mathbf{u}^{c}_{\lambda,s}}$</span> and <span>$\vec{\mathbf{v}^{c}_{\lambda,s}}$</span> must be the same. The notation of the vertex relational composition is:</p><p class="math-container">\[R_{\lambda}^+ = {\vec{\mathbf{u}^{c}_{\lambda,s}} R^+ \vec{\mathbf{v}^{c}_{\lambda,s}}}_{color}\]</p><p>The simple/complete relationship observation above can be applied in this instance. <span>$\vec{\mathbf{u}^{c}_{\lambda,c}} = \vec{\mathbf{u}^{c}_{\lambda,s}} * R^+$</span> and <span>$\vec{\mathbf{v}^{c}_{\lambda,c}} = R^+ * \vec{\mathbf{v}^{c}_{\lambda,s}}$</span>. </p><p class="math-container">\[\vec{\mathbf{u}^{c}_{\lambda,c}}\]</p><p>and <span>$\vec{\mathbf{v}^{c}_{\lambda,c}}$</span> are the row and column, respectively, that need to be appended to <span>$R^+$</span> (along with the final diagonal element corresponding to <span>$\lambda$</span>&#39;s color) to compose <span>$R_{\lambda}^+$</span>. Appending the complete compositional vectors to <span>$R^+$</span> isn&#39;t sufficient to compose <span>$R_{\lambda}^+$</span>. The &quot;body&quot; of <span>$R^+$</span> needs to be &quot;updated&quot; to ensure that <span>$R_{\lambda}^+$</span> is also transitively closed. For each row in <span>$R^+$</span>, every element in that row is set to the avus product of the corresponding column element in <span>$\vec{\mathbf{v}^{c}_{\lambda,c}}$</span> and the corresponding row element in <span>$\vec{\mathbf{u}^{c}_{\lambda,c}}$</span>.</p><p>Expressing this algorithmically:</p><ol><li>generate <span>$\vec{\mathbf{u}^{c}_{\lambda,c}} = \vec{\mathbf{u}^{c}_{\lambda,s}} * R^+$</span></li><li>generate <span>$\vec{\mathbf{v}^{c}_{\lambda,c}} = R^+ * \vec{\mathbf{v}^{c}_{\lambda,s}}$</span></li><li>Compose <span>$R_{\lambda}^+$</span> by:<ol><li>appending <span>$\mathbf{u}^{c}_{\lambda,c}$</span> to <span>$R^+$</span> as a new row </li><li>appending <span>$\mathbf{v}^{c}_{\lambda,c}$</span> to <span>$R^+$</span> as a new column</li><li>setting the diagnoal element <span>${R_{\lambda}^+}_{N+1, N+1}$</span> to either 1 or <span>${\color{red}1}$</span> depending on the color of the composition.</li><li>For each row, <span>$i$</span>, and each column, <span>$j$</span>, where <span>$\vec{\mathbf{u}^{c}_{\lambda,c}}_{j} \neq 0$</span>, set <span>${R_{\lambda}^{+}}_{i,j} = \vec{\mathbf{u}^{c}_{\lambda,c}}_{j} * \vec{\mathbf{v}^{c}_{\lambda,c}}_{i}$</span></li></ol></li></ol><h3 id="Adding-an-Edge-to-R"><a class="docs-heading-anchor" href="#Adding-an-Edge-to-R">Adding an Edge to <span>$R^+$</span></a><a id="Adding-an-Edge-to-R-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-an-Edge-to-R" title="Permalink"></a></h3><p>[<strong>TODO</strong>: This notation is muddy. Need to rework this section]</p><p>Consider the case of adding a new edge to a red black graph. The operation of adding a new edge to a graph is designated the &quot;edge relational composition&quot;. The new edge is added between two existing vertices, <span>$vertex_\alpha$</span> and <span>$vertex_\beta$</span>. The notation of the edge relational composition is:</p><p class="math-container">\[R^+_\lambda = R^+ * r(\mathbf{\alpha}, \mathbf{\beta})\]</p><p>As in the vertex relational composition, we&#39;ll make use of the simple/complete relational observation. In this case, the row representing <span>$vertex_\alpha$</span> is replaced with the avus product of itself (with <span>$element_\beta$</span> replaced with <span>$r(\mathbf{\alpha}, \mathbf{\beta})$</span>) and <span>$R^+$</span>. Notationally: <span>$R^{+&#39;} = R^+ +_\alpha ((vertex_\alpha +_\beta r(\mathbf{\alpha}, \mathbf{\beta})) * R^+)$</span> where <span>$+_i$</span> designates replacement of element <span>$i$</span> in the LHS with the value of the RHS. As in the vertex relational composition, replacing row vector <span>$\alpha$</span> with it&#39;s complete form isn&#39;t sufficient to compose <span>$R_{\lambda}^+$</span>. The remainder of the row vectors need to be closed with the new relationship. For each row, <span>$i$</span>, in <span>$R^{+&#39;}$</span> excluding <span>$\alpha$</span>, every element, <span>$j$</span> in that row is set to <span>$R^{+&#39;}_{i,\alpha} * R^{+&#39;}_{\alpha,j}$</span>.</p><p>Expressing this algorithmically:</p><ol><li>generate <span>$\vec{\mathbf{u}^{&#39;}_\alpha} = \vec{\mathbf{u}_\alpha} +_{\beta} r(\mathbf{\alpha},\mathbf{\beta})$</span>, where <span>$\vec{\mathbf{u}_\alpha}$</span> is row <span>$\alpha$</span> in <span>$R^+$</span></li><li>generate <span>$\vec{\mathbf{u}^{c&#39;}_\alpha} = \vec{\mathbf{u}^{&#39;}_\alpha} * R^+$</span></li><li>Compose <span>$R_{\lambda}^+$</span> by:<ol><li>replacing row <span>$\alpha$</span> in <span>$R^+$</span>: <span>$R^{+&#39;} = R^+ +_{\beta} \vec{\mathbf{u}^{c&#39;}_a\alpha}$</span> </li><li>For each row, <span>$i$</span>, and each column, <span>$j$</span>, where <span>$i \neq \alpha$</span>, set <span>${R_{\lambda}^{+}}_{i,j} = R^{+&#39;}_{i,\alpha} * R^{+&#39;}_{\alpha,j}$</span></li></ol></li></ol><h2 id="Applications-of-Avus-Linear-Algebra"><a class="docs-heading-anchor" href="#Applications-of-Avus-Linear-Algebra">Applications of Avus Linear Algebra</a><a id="Applications-of-Avus-Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Applications-of-Avus-Linear-Algebra" title="Permalink"></a></h2><h3 id="Loop-Prevention"><a class="docs-heading-anchor" href="#Loop-Prevention">Loop Prevention</a><a id="Loop-Prevention-1"></a><a class="docs-heading-anchor-permalink" href="#Loop-Prevention" title="Permalink"></a></h3><p>An issue that can be encountered in systems that represent familial relationships is the inadvertent injection of graph cycles, resulting in the <a href="https://en.wikipedia.org/wiki/I%27m_My_Own_Grandpa">&quot;I am my own Grandpa&quot;</a> case. While this is impossible when relationships model sexual reproduction, the introduction of step-relationships, etc. would make this a possibility. Often times there is ambiguity in the available historical records. If a researcher isn&#39;t careful, cylces may result as a genealogical model is created. Modifications to both forms of the relational composition algorithms can prevent the introduction of cycles into the graph. </p><h4 id="Vertex-Relational-Composition-Loop-Prevention"><a class="docs-heading-anchor" href="#Vertex-Relational-Composition-Loop-Prevention">Vertex Relational Composition Loop Prevention</a><a id="Vertex-Relational-Composition-Loop-Prevention-1"></a><a class="docs-heading-anchor-permalink" href="#Vertex-Relational-Composition-Loop-Prevention" title="Permalink"></a></h4><p>As vertices are added to an existing graph via relational composition, the intermedite, complete compositional vectors, <span>$\vec{\mathbf{u}^{c}_{\lambda, c}}$</span> and <span>$\vec{\mathbf{v}^{c}_{\lambda, s}}$</span> represent the complete ancestry and complete descedency for the new vertex <span>$\lambda$</span> respectively. The cycle constraint would be invalidated should there be any vertex that simultaneously appears in the ancestry and descendency for a given vertex.</p><p>Given <span>$\vec{\mathbf{u}^{c}_{\lambda, c}}$</span> and <span>$\vec{\mathbf{v}^{c}_{\lambda, s}}$</span> of dimension <span>$n$</span>, the <strong>vertex relational composition</strong> is undefined if there exists a dimension <span>$i$</span> where <span>$i \neq n \land \vec{\mathbf{u}^{c}_{\lambda, c}}_{i} \neq 0 \land \vec{\mathbf{v}^{c}_{\lambda, s}}_{i} \neq 0$</span> and is well-formed otherwise.</p><h4 id="Edge-Relational-Composition-Loop-Prevention"><a class="docs-heading-anchor" href="#Edge-Relational-Composition-Loop-Prevention">Edge Relational Composition Loop Prevention</a><a id="Edge-Relational-Composition-Loop-Prevention-1"></a><a class="docs-heading-anchor-permalink" href="#Edge-Relational-Composition-Loop-Prevention" title="Permalink"></a></h4><p>This case is trivial with a transitively closed matrix. Given <span>$R^+$</span> and <span>$r(\mathbf{\alpha},\mathbf{\beta})$</span>, the <strong>edge relational composition</strong> is undefined if <span>$r(\mathbf{\beta},\mathbf{\alpha}) \neq 0$</span> and well-formed otherwise.</p><h3 id="Connected-Component-Identification"><a class="docs-heading-anchor" href="#Connected-Component-Identification">Connected Component Identification</a><a id="Connected-Component-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Connected-Component-Identification" title="Permalink"></a></h3><p>[<strong>TODO</strong>: rework this section to tie together topological sort + component identification in a single DFS pass. This will be more efficient than current algorithm.]</p><p>As Red Black Graphs are used to represent family relationships, an interesting case is determining how many disjoint trees are represetned within a graph. Tarjan&#39;s algorithm is typically used to compute the connected components of a graph. In the case of a transitively closed adjacency matrix, the depth first search used in Tarjan&#39;s algorithm is inherently &quot;pre-computed&quot;. Because of this property, Tarjan&#39;s algorithm can be simplified.</p><p>Consider the following graph</p><p><img src="assets/img/find-components.png" alt="Graph with Components"/></p><p>By inspection, there are two components and the application of the simplified Tarjan&#39;s algorithm identifies which vertices belong to which components.</p><p>With an efficient sparse representation this algorithm is also <span>$\mathbf{O}(|V| + |E|)$</span>.</p><h2 id="RedBlackGraph-Canonical-Form"><a class="docs-heading-anchor" href="#RedBlackGraph-Canonical-Form">RedBlackGraph Canonical Form</a><a id="RedBlackGraph-Canonical-Form-1"></a><a class="docs-heading-anchor-permalink" href="#RedBlackGraph-Canonical-Form" title="Permalink"></a></h2><p>Returning to the example, it is obvious from inspection that one component consists of 4 nodes, the other of 3 and that the diamter of the larger component is 2, while the diamter of the smaller is 1. As this information is readily available in the Red Black Graph, it is easily added to the <span>$find\_components$</span> algorithm (see the following <span>$find\_components\_extended$</span> algorithm). Observe thatsymetrically permuting a matrix corresponds to relabeling the vertices of the associated graph. I will show that with an appropriate relabeling of the graph vertices the Red Black graph adjacency matrix is upper triangular, <span>$R^{+_c}$</span> or canonical form. I will also show that <span>$R^{+_c} = \mathbf{P} R^+ \mathbf{P}^\top$</span> where <span>$\mathbf{P}$</span> is a permutation matrix derived from the count of the vertices in a component. <span>$\mathbf{P}$</span> will be chosen such that <span>$R^{+_c}$</span> in addition to being upper triangular, each graph component and its diameter is readily identified.</p><p>To arrive at <span>$\mathbf{P}$</span> the list of nodes is sorted (in reverse order) first on the size of the encompassing connected component, secondly on the identifier of the connected component and finally on the maximum <span>$r(\mathbf{u},\mathbf{v})$</span> for the vertex. The vertices are then labeled based on this sorting, e.g. the <span>$zero^{th}$</span> vertex is the vetex from the largest connected component that has the greatest <span>$r(\mathbf{u},\mathbf{v})$</span> (or most distant ancestor) on down to the <span>$n^{th}$</span> vertex which is the vertex from the smallest connected component with no (or nearest) ancestor. (Ordering is arbitrary for vertices with identical sort keys.)</p><p>A simple implementation of triangularizing <span>$R$</span> based on the properties inherent in the adjacency matrix and the extended <span>$find\_components$</span> algorithm follows.</p><p><img src="assets/img/canonical.png" alt="Graph with Components (Canonical Form)"/></p><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RedBlackGraph.AInteger" href="#RedBlackGraph.AInteger"><code>RedBlackGraph.AInteger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AInteger (or Avus Integer)</code></pre><p>Integers that follow Avus definition for addition and multiplication. AIntegers also have a distinct integer, <span>$\color{red}1$</span>, where:</p><ul><li><span>$0 &lt; {\color{red}1} &lt; 1$</span></li><li>iseven(<span>${\color{red}1}$</span>) == true</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/avus.jl#L2-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedBlackGraph.Relationship" href="#RedBlackGraph.Relationship"><code>RedBlackGraph.Relationship</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Relationship</code></pre><p>A structure designed to capture the relationship between two individuals</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/relationship.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AInteger, AInteger}" href="#Base.:*-Tuple{AInteger, AInteger}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(x::Integer, y::Integer)</code></pre><p>Avus Product or transitive relationship function.</p><p>Consider 3 vertices: u, v and w. Furthermore, assume that there is a path from u to v, represented as x, and from v to w, represented as y.</p><p>The Avus Product provides the path from u to w, represented as z, e.g. z = x ⨰ y</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/avus.jl#L185-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{AInteger, AInteger}" href="#Base.:+-Tuple{AInteger, AInteger}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(x::Integer, y::Integer)</code></pre><p>Avus Sum or min(x, y) where min(0) == ∞ and <span>${\color{red}1} &lt; 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/avus.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;-Tuple{AInteger, AInteger}" href="#Base.:&lt;-Tuple{AInteger, AInteger}"><code>Base.:&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">&lt;(x::AInteger, y::AInteger)</code></pre><p>for comparison purpose, 0 compares as ∞ and <span>$\color{red}1$</span> is the least value of any AInteger</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/avus.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iseven-Tuple{AInteger}" href="#Base.iseven-Tuple{AInteger}"><code>Base.iseven</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iseven(x::AInteger) -&gt; Bool</code></pre><p>Return <code>true</code> if <code>x</code> is even (that is, divisible by 2) or <span>$\color{red}1$</span>, and <code>false</code> otherwise.</p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/avus.jl#L164-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedBlackGraph.floyd_warshall_transitive_closure-Union{Tuple{Matrix{A}}, Tuple{A}} where A&lt;:AInteger" href="#RedBlackGraph.floyd_warshall_transitive_closure-Union{Tuple{Matrix{A}}, Tuple{A}} where A&lt;:AInteger"><code>RedBlackGraph.floyd_warshall_transitive_closure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floyd_warshall_transitive_closure(g)</code></pre><p>Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the transistive closure of a redblackgraph <code>g</code>. Return a Matrix{AInteger} that represents the transitive closure of the redblackgraph adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/shortestpaths/floyd-warshall.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedBlackGraph.lookup_relationship-Tuple{Integer, Integer}" href="#RedBlackGraph.lookup_relationship-Tuple{Integer, Integer}"><code>RedBlackGraph.lookup_relationship</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lookup_relationship(AInteger, AInteger)</code></pre><p>Given two individuals with a common ancestor where the first parameter is the generational distance from the first individual to the common ancestor and the second parameter is the generational distance from the second individual to the common ancestor, this function provides a string representation of how the two individuals are related.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/relationship.jl#L36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RedBlackGraph.red_one-Tuple{AInteger}" href="#RedBlackGraph.red_one-Tuple{AInteger}"><code>RedBlackGraph.red_one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">red_one(x)
red_one(T::type)</code></pre><p>Return a <span>$\color{red}1$</span> for <code>x</code>: a value such that <span>${\color{red}1} + 1 == {\color{red}1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rappdw/RedBlackGraph.jl/blob/6512a0a21c1cc3425f49564a3a827d9871c212fb/src/avus.jl#L77-L83">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 15 January 2022 16:57">Saturday 15 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
